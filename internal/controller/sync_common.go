// Package controller contains shared sync logic for the vault-sync-operator.
package controller

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"github.com/go-logr/logr"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/types"
	"sigs.k8s.io/controller-runtime/pkg/client"

	"github.com/danieldonoghue/vault-sync-operator/internal/metrics"
	"github.com/danieldonoghue/vault-sync-operator/internal/vault"
)

// SyncContext provides common context for sync operations.
type SyncContext struct {
	Client      client.Client
	VaultClient *vault.Client
	Log         logr.Logger
	ClusterName string
}

// ResourceInfo holds information about the resource being synced.
type ResourceInfo struct {
	Name      string
	Namespace string
	Type      string // "deployment" or "secret"
}

// Note: SecretConfig is defined in deployment_controller.go to avoid duplication

// SyncCustomSecretsWithVersions handles custom secret configuration and returns version information.
func (sc *SyncContext) SyncCustomSecretsWithVersions(ctx context.Context, resource ResourceInfo, secretsConfig string, targetNamespace string) (map[string]interface{}, map[string]string, error) {
	log := sc.Log.WithValues("resource_type", resource.Type, "resource", resource.Name, "namespace", resource.Namespace)

	// Parse the secrets annotation (JSON format)
	var secretConfigs []SecretConfig
	if err := json.Unmarshal([]byte(secretsConfig), &secretConfigs); err != nil {
		metrics.ConfigParseErrors.WithLabelValues(resource.Namespace, resource.Name, "json_parse_error").Inc()
		log.Error(err, "failed to parse secrets annotation",
			"annotation", secretsConfig,
			"error_type", "json_parse_error",
			"resource_type", resource.Type)
		return nil, nil, fmt.Errorf("failed to parse secrets annotation: %w", err)
	}

	log.Info("parsed custom secret configuration", "secret_configs", len(secretConfigs))

	// Collect all secret data and versions
	vaultData := make(map[string]interface{})
	secretVersions := make(map[string]string)

	for _, secretConfig := range secretConfigs {
		secret := &corev1.Secret{}
		secretKey := types.NamespacedName{
			Name:      secretConfig.Name,
			Namespace: targetNamespace, // Use the provided namespace (could be different for cross-namespace refs)
		}

		if err := sc.Client.Get(ctx, secretKey, secret); err != nil {
			metrics.SecretNotFoundErrors.WithLabelValues(targetNamespace, secretConfig.Name).Inc()
			log.Error(err, "failed to get secret - it may be generated by kustomize or similar tools",
				"secret", secretConfig.Name,
				"target_namespace", targetNamespace,
				"resource_type", resource.Type,
				"resource", resource.Name,
				"suggestion", "ensure secret generators run before operator sync")
			return nil, nil, fmt.Errorf("failed to get secret %s (check if secret generators have run): %w", secretConfig.Name, err)
		}

		// Track secret version for rotation detection
		secretVersions[secretConfig.Name] = secret.ResourceVersion

		// Add specified keys to vault data
		for _, key := range secretConfig.Keys {
			if data, exists := secret.Data[key]; exists {
				// Use prefix if specified
				vaultKey := key
				if secretConfig.Prefix != "" {
					vaultKey = secretConfig.Prefix + key
				}
				vaultData[vaultKey] = string(data)
			} else {
				metrics.SecretKeyMissingError.WithLabelValues(targetNamespace, secretConfig.Name, key).Inc()
				log.Error(fmt.Errorf("key not found in secret"), "key not found",
					"secret", secretConfig.Name,
					"key", key,
					"available_keys", getSecretKeys(secret.Data),
					"target_namespace", targetNamespace,
					"resource_type", resource.Type,
					"resource", resource.Name)
				return nil, nil, fmt.Errorf("key %s not found in secret %s", key, secretConfig.Name)
			}
		}
	}

	return vaultData, secretVersions, nil
}

// SyncAllSecretKeys syncs all keys from a single secret (used when no custom config provided).
func (sc *SyncContext) SyncAllSecretKeys(ctx context.Context, resource ResourceInfo, secret *corev1.Secret) (map[string]interface{}, map[string]string, error) {
	log := sc.Log.WithValues("resource_type", resource.Type, "resource", resource.Name, "namespace", resource.Namespace)

	// Create vault data from all secret keys
	vaultData := make(map[string]interface{})
	for key, value := range secret.Data {
		vaultData[key] = string(value)
	}

	// Track secret version for rotation detection
	secretVersions := map[string]string{
		secret.Name: secret.ResourceVersion,
	}

	log.Info("syncing all secret keys",
		"secret", secret.Name,
		"key_count", len(vaultData))

	return vaultData, secretVersions, nil
}

// WriteSecretToVault writes secret data to Vault with cluster prefixing.
func (sc *SyncContext) WriteSecretToVault(ctx context.Context, vaultPath string, vaultData map[string]interface{}, resource ResourceInfo) error {
	log := sc.Log.WithValues("resource_type", resource.Type, "resource", resource.Name, "namespace", resource.Namespace)

	// Add cluster prefix if cluster name is configured
	if sc.ClusterName != "" {
		vaultPath = fmt.Sprintf("clusters/%s/%s", sc.ClusterName, vaultPath)
	}

	// Start timing the operation
	start := time.Now()
	defer func() {
		duration := time.Since(start).Seconds()
		metrics.SecretsyncDuration.WithLabelValues(resource.Namespace, resource.Name).Observe(duration)
	}()

	// Log what we're about to sync
	log.Info("writing secret to vault",
		"path", vaultPath,
		"key_count", len(vaultData))

	// Write to Vault
	if err := sc.VaultClient.WriteSecret(ctx, vaultPath, vaultData); err != nil {
		metrics.SecretsyncAttempts.WithLabelValues(resource.Namespace, resource.Name, "failed").Inc()
		log.Error(err, "failed to write secret to vault",
			"path", vaultPath,
			"key_count", len(vaultData),
			"error_details", err.Error())
		return fmt.Errorf("failed to write secret to vault: %w", err)
	}

	// Success metrics and logging
	metrics.SecretsyncAttempts.WithLabelValues(resource.Namespace, resource.Name, "success").Inc()
	log.Info("successfully wrote secret to vault",
		"path", vaultPath,
		"key_count", len(vaultData),
		"duration_seconds", time.Since(start).Seconds())

	return nil
}

// DeleteSecretFromVault deletes a secret from Vault with cluster prefixing.
func (sc *SyncContext) DeleteSecretFromVault(ctx context.Context, vaultPath string, resource ResourceInfo) error {
	log := sc.Log.WithValues("resource_type", resource.Type, "resource", resource.Name, "namespace", resource.Namespace)

	// Add cluster prefix if cluster name is configured
	if sc.ClusterName != "" {
		vaultPath = fmt.Sprintf("clusters/%s/%s", sc.ClusterName, vaultPath)
	}

	// Delete the secret from Vault
	if err := sc.VaultClient.DeleteSecret(ctx, vaultPath); err != nil {
		log.Error(err, "failed to delete secret from vault",
			"path", vaultPath,
			"error_details", err.Error())
		return err
	}

	log.Info("successfully deleted secret from vault",
		"path", vaultPath)
	return nil
}

// DetectSecretChanges compares last known versions with current versions to detect changes.
func (sc *SyncContext) DetectSecretChanges(lastVersions, currentVersions map[string]string) bool {
	// If no previous versions exist, consider it a change (initial sync)
	if len(lastVersions) == 0 {
		return true
	}

	// Check if any secret version has changed
	for secretName, currentVersion := range currentVersions {
		if lastVersion, exists := lastVersions[secretName]; !exists || lastVersion != currentVersion {
			return true
		}
	}

	// Check if any secret was removed
	for secretName := range lastVersions {
		if _, exists := currentVersions[secretName]; !exists {
			return true
		}
	}

	return false
}

// GetChangedSecrets returns a list of secrets that have changed versions.
func (sc *SyncContext) GetChangedSecrets(lastVersions, currentVersions map[string]string) []string {
	var changed []string

	// Find changed secrets
	for secretName, currentVersion := range currentVersions {
		if lastVersion, exists := lastVersions[secretName]; !exists || lastVersion != currentVersion {
			changed = append(changed, secretName)
		}
	}

	// Find removed secrets
	for secretName := range lastVersions {
		if _, exists := currentVersions[secretName]; !exists {
			changed = append(changed, secretName+" (removed)")
		}
	}

	return changed
}

// Note: getSecretKeys is defined in deployment_controller.go to avoid duplication

// ParseSecretVersionsAnnotation parses the secret versions annotation.
func ParseSecretVersionsAnnotation(annotationValue string, log logr.Logger, resourceName, resourceNamespace string) map[string]string {
	if annotationValue == "" {
		return make(map[string]string)
	}

	var versions map[string]string
	if err := json.Unmarshal([]byte(annotationValue), &versions); err != nil {
		log.Error(err, "failed to parse secret versions annotation",
			"annotation", annotationValue,
			"resource", resourceName,
			"namespace", resourceNamespace)
		return make(map[string]string)
	}

	return versions
}

// UpdateSecretVersionsAnnotation updates a resource with current secret versions.
func UpdateSecretVersionsAnnotation(ctx context.Context, k8sClient client.Client, obj client.Object, versions map[string]string) error {
	versionsJSON, err := json.Marshal(versions)
	if err != nil {
		return fmt.Errorf("failed to marshal secret versions: %w", err)
	}

	// Create a copy to update
	objCopy := obj.DeepCopyObject().(client.Object)
	annotations := objCopy.GetAnnotations()
	if annotations == nil {
		annotations = make(map[string]string)
	}
	annotations[VaultSecretVersionsAnnotation] = string(versionsJSON)
	objCopy.SetAnnotations(annotations)

	// Update the object
	if err := k8sClient.Update(ctx, objCopy); err != nil {
		return fmt.Errorf("failed to update resource annotations: %w", err)
	}

	return nil
}