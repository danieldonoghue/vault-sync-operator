name: Release

on:
  push:
    tags:
      - 'v*'

env:
  GO_VERSION: "1.24"
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  create-release:
    name: Create Release
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: read
    outputs:
      release_id: ${{ steps.create_release.outputs.id }}
      upload_url: ${{ steps.create_release.outputs.upload_url }}
      version: ${{ steps.get_version.outputs.version }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Get version from tag
      id: get_version
      run: echo "version=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT

    - name: Generate changelog
      id: changelog
      run: |
        # Get the latest two tags
        PREVIOUS_TAG=$(git tag --sort=-version:refname | sed -n '2p')
        CURRENT_TAG=${{ steps.get_version.outputs.version }}
        
        # If no previous tag, use initial commit
        if [ -z "$PREVIOUS_TAG" ]; then
          PREVIOUS_TAG=$(git rev-list --max-parents=0 HEAD)
        fi
        
        # Generate changelog
        echo "## Changes" > CHANGELOG.md
        echo "" >> CHANGELOG.md
        git log --pretty=format:"- %s (%h)" ${PREVIOUS_TAG}..${CURRENT_TAG} >> CHANGELOG.md
        echo "" >> CHANGELOG.md
        echo "" >> CHANGELOG.md
        echo "**Full Changelog**: https://github.com/${{ github.repository }}/compare/${PREVIOUS_TAG}...${CURRENT_TAG}" >> CHANGELOG.md

    - name: Create Release
      id: create_release
      run: |
        # Create the release using GitHub CLI
        CHANGELOG_BODY=$(cat CHANGELOG.md)
        PRERELEASE_FLAG=""
        if [[ "${{ steps.get_version.outputs.version }}" == *"-"* ]]; then
          PRERELEASE_FLAG="--prerelease"
        fi
        
        RELEASE_OUTPUT=$(gh release create "${{ steps.get_version.outputs.version }}" \
          --title "Release ${{ steps.get_version.outputs.version }}" \
          --notes "${CHANGELOG_BODY}" \
          ${PRERELEASE_FLAG} \
          --generate-notes)
        
        # Extract upload URL and release ID for compatibility
        RELEASE_ID=$(gh api repos/${{ github.repository }}/releases/tags/${{ steps.get_version.outputs.version }} --jq '.id')
        UPLOAD_URL=$(gh api repos/${{ github.repository }}/releases/tags/${{ steps.get_version.outputs.version }} --jq '.upload_url')
        
        echo "id=${RELEASE_ID}" >> $GITHUB_OUTPUT
        echo "upload_url=${UPLOAD_URL}" >> $GITHUB_OUTPUT
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  build-binaries:
    name: Build Binaries
    runs-on: ubuntu-latest
    needs: create-release
    permissions:
      contents: write
    strategy:
      matrix:
        goos: [linux, darwin, windows]
        goarch: [amd64, arm64]
        exclude:
          - goos: windows
            goarch: arm64
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v5
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: Cache Go modules
      uses: actions/cache@v4
      with:
        path: |
          ~/.cache/go-build
          ~/go/pkg/mod
        key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-

    - name: Build binary
      env:
        GOOS: ${{ matrix.goos }}
        GOARCH: ${{ matrix.goarch }}
        CGO_ENABLED: 0
      run: |
        BINARY_NAME="vault-sync-operator-${{ matrix.goos }}-${{ matrix.goarch }}"
        if [ "${{ matrix.goos }}" = "windows" ]; then
          BINARY_NAME="${BINARY_NAME}.exe"
        fi
        
        go build \
          -a \
          -ldflags="-w -s -extldflags '-static' -X main.version=${{ needs.create-release.outputs.version }} -X main.commit=${{ github.sha }} -X main.date=$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
          -tags netgo,osusergo \
          -o "${BINARY_NAME}" \
          cmd/main.go

    - name: Create archive
      id: archive
      run: |
        BINARY_NAME="vault-sync-operator-${{ matrix.goos }}-${{ matrix.goarch }}"
        if [ "${{ matrix.goos }}" = "windows" ]; then
          BINARY_NAME="${BINARY_NAME}.exe"
          ARCHIVE_NAME="vault-sync-operator-${{ needs.create-release.outputs.version }}-${{ matrix.goos }}-${{ matrix.goarch }}.zip"
          zip "${ARCHIVE_NAME}" "${BINARY_NAME}" README.md LICENSE
        else
          ARCHIVE_NAME="vault-sync-operator-${{ needs.create-release.outputs.version }}-${{ matrix.goos }}-${{ matrix.goarch }}.tar.gz"
          tar -czf "${ARCHIVE_NAME}" "${BINARY_NAME}" README.md LICENSE
        fi
        echo "archive_name=${ARCHIVE_NAME}" >> $GITHUB_OUTPUT
        echo "binary_name=${BINARY_NAME}" >> $GITHUB_OUTPUT

    - name: Upload Release Asset
      run: |
        gh release upload ${{ needs.create-release.outputs.version }} ${{ steps.archive.outputs.archive_name }}
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Generate SHA256 checksums
      run: |
        sha256sum ${{ steps.archive.outputs.archive_name }} > ${{ steps.archive.outputs.archive_name }}.sha256

    - name: Upload Checksum
      run: |
        gh release upload ${{ needs.create-release.outputs.version }} ${{ steps.archive.outputs.archive_name }}.sha256
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  build-and-push-docker:
    name: Build and Push Docker Images
    runs-on: ubuntu-latest
    needs: create-release
    permissions:
      contents: read
      packages: write
    strategy:
      fail-fast: false
      matrix:
        platform:
          - linux/amd64
          - linux/arm64
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Prepare
      run: |
        platform=${{ matrix.platform }}
        echo "PLATFORM_PAIR=${platform//\//-}" >> $GITHUB_ENV

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=tag
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          type=semver,pattern={{major}}
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Set up QEMU
      uses: docker/setup-qemu-action@v3

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.CR_PAT }}

    - name: Build and push by digest
      id: build
      uses: docker/build-push-action@v6
      with:
        context: .
        platforms: ${{ matrix.platform }}
        labels: ${{ steps.meta.outputs.labels }}
        outputs: type=image,name=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }},push-by-digest=true,name-canonical=true,push=true
        build-args: |
          VERSION=${{ needs.create-release.outputs.version }}
          COMMIT=${{ github.sha }}
          DATE=${{ github.event.head_commit.timestamp }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Export digest
      run: |
        mkdir -p /tmp/digests
        digest="${{ steps.build.outputs.digest }}"
        touch "/tmp/digests/${digest#sha256:}"

    - name: Upload digest
      uses: actions/upload-artifact@v4
      with:
        name: digests-${{ env.PLATFORM_PAIR }}
        path: /tmp/digests/*
        if-no-files-found: error
        retention-days: 1

  merge:
    name: Merge multi-platform manifests
    runs-on: ubuntu-latest
    needs: 
      - create-release
      - build-and-push-docker
    permissions:
      contents: read
      packages: write
    steps:
    - name: Download digests
      uses: actions/download-artifact@v4
      with:
        path: /tmp/digests
        pattern: digests-*
        merge-multiple: true

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.CR_PAT }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=tag
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          type=semver,pattern={{major}}
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Create manifest list and push
      working-directory: /tmp/digests
      run: |
        docker buildx imagetools create $(jq -cr '.tags | map("-t " + .) | join(" ")' <<< "$DOCKER_METADATA_OUTPUT_JSON") \
          $(printf '${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@sha256:%s ' *)

    - name: Inspect image
      run: |
        docker buildx imagetools inspect ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.meta.outputs.version }}

    - name: Generate SBOM
      uses: anchore/sbom-action@v0
      with:
        image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.create-release.outputs.version }}
        format: spdx-json
        output-file: sbom.spdx.json

    - name: Upload SBOM to Release
      run: |
        mv sbom.spdx.json vault-sync-operator-${{ needs.create-release.outputs.version }}-sbom.spdx.json
        gh release upload ${{ needs.create-release.outputs.version }} vault-sync-operator-${{ needs.create-release.outputs.version }}-sbom.spdx.json
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  update-manifests:
    name: Update Kubernetes Manifests
    runs-on: ubuntu-latest
    needs: [create-release, merge]
    permissions:
      contents: write
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Update image version in manifests
      run: |
        VERSION=${{ needs.create-release.outputs.version }}
        # Update the image tag in the manager manifest
        sed -i "s|image: ghcr.io/${{ github.repository }}:.*|image: ghcr.io/${{ github.repository }}:${VERSION}|g" config/manager/manager.yaml
        
        # Create a versioned release manifest
        mkdir -p releases/${VERSION}
        cp -r config/* releases/${VERSION}/
        
        # Update kustomization.yaml with new image
        cat > releases/${VERSION}/kustomization.yaml << EOF
        apiVersion: kustomize.config.k8s.io/v1beta1
        kind: Kustomization
        
        resources:
        - crd/
        - rbac/
        - manager/
        
        images:
        - name: vault-sync-operator
          newName: ghcr.io/${{ github.repository }}
          newTag: ${VERSION}
        EOF

    - name: Create release manifest archive
      run: |
        VERSION=${{ needs.create-release.outputs.version }}
        cd releases/${VERSION}
        tar -czf ../../vault-sync-operator-manifests-${VERSION}.tar.gz .
        cd ../..

    - name: Upload Manifests to Release
      run: |
        gh release upload ${{ needs.create-release.outputs.version }} vault-sync-operator-manifests-${{ needs.create-release.outputs.version }}.tar.gz
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
