name: Release

on:
  push:
    tags:
      - 'v*'

env:
  GO_VERSION: "1.24"
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  create-release:
    name: Create Release
    runs-on: ubuntu-latest
    outputs:
      release_id: ${{ steps.create_release.outputs.id }}
      upload_url: ${{ steps.create_release.outputs.upload_url }}
      version: ${{ steps.get_version.outputs.version }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Get version from tag
      id: get_version
      run: echo "version=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT

    - name: Generate changelog
      id: changelog
      run: |
        # Get the latest two tags
        PREVIOUS_TAG=$(git tag --sort=-version:refname | sed -n '2p')
        CURRENT_TAG=${{ steps.get_version.outputs.version }}
        
        # If no previous tag, use initial commit
        if [ -z "$PREVIOUS_TAG" ]; then
          PREVIOUS_TAG=$(git rev-list --max-parents=0 HEAD)
        fi
        
        # Generate changelog
        echo "## Changes" > CHANGELOG.md
        echo "" >> CHANGELOG.md
        git log --pretty=format:"- %s (%h)" ${PREVIOUS_TAG}..${CURRENT_TAG} >> CHANGELOG.md
        echo "" >> CHANGELOG.md
        echo "" >> CHANGELOG.md
        echo "**Full Changelog**: https://github.com/${{ github.repository }}/compare/${PREVIOUS_TAG}...${CURRENT_TAG}" >> CHANGELOG.md

    - name: Create Release
      id: create_release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ steps.get_version.outputs.version }}
        release_name: Release ${{ steps.get_version.outputs.version }}
        body_path: CHANGELOG.md
        draft: false
        prerelease: ${{ contains(steps.get_version.outputs.version, '-') }}

  build-binaries:
    name: Build Binaries
    runs-on: ubuntu-latest
    needs: create-release
    strategy:
      matrix:
        goos: [linux, darwin, windows]
        goarch: [amd64, arm64]
        exclude:
          - goos: windows
            goarch: arm64
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v5
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: Cache Go modules
      uses: actions/cache@v4
      with:
        path: |
          ~/.cache/go-build
          ~/go/pkg/mod
        key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-

    - name: Build binary
      env:
        GOOS: ${{ matrix.goos }}
        GOARCH: ${{ matrix.goarch }}
        CGO_ENABLED: 0
      run: |
        BINARY_NAME="vault-sync-operator-${{ matrix.goos }}-${{ matrix.goarch }}"
        if [ "${{ matrix.goos }}" = "windows" ]; then
          BINARY_NAME="${BINARY_NAME}.exe"
        fi
        
        go build \
          -a \
          -ldflags="-w -s -extldflags '-static' -X main.version=${{ needs.create-release.outputs.version }} -X main.commit=${{ github.sha }} -X main.date=$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
          -tags netgo,osusergo \
          -o "${BINARY_NAME}" \
          cmd/main.go

    - name: Create archive
      run: |
        BINARY_NAME="vault-sync-operator-${{ matrix.goos }}-${{ matrix.goarch }}"
        if [ "${{ matrix.goos }}" = "windows" ]; then
          BINARY_NAME="${BINARY_NAME}.exe"
          ARCHIVE_NAME="vault-sync-operator-${{ needs.create-release.outputs.version }}-${{ matrix.goos }}-${{ matrix.goarch }}.zip"
          zip "${ARCHIVE_NAME}" "${BINARY_NAME}" README.md LICENSE
        else
          ARCHIVE_NAME="vault-sync-operator-${{ needs.create-release.outputs.version }}-${{ matrix.goos }}-${{ matrix.goarch }}.tar.gz"
          tar -czf "${ARCHIVE_NAME}" "${BINARY_NAME}" README.md LICENSE
        fi
        echo "ARCHIVE_NAME=${ARCHIVE_NAME}" >> $GITHUB_ENV
        echo "BINARY_NAME=${BINARY_NAME}" >> $GITHUB_ENV

    - name: Upload Release Asset
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ needs.create-release.outputs.upload_url }}
        asset_path: ./${{ env.ARCHIVE_NAME }}
        asset_name: ${{ env.ARCHIVE_NAME }}
        asset_content_type: application/octet-stream

    - name: Generate SHA256 checksums
      run: |
        sha256sum ${{ env.ARCHIVE_NAME }} > ${{ env.ARCHIVE_NAME }}.sha256

    - name: Upload Checksum
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ needs.create-release.outputs.upload_url }}
        asset_path: ./${{ env.ARCHIVE_NAME }}.sha256
        asset_name: ${{ env.ARCHIVE_NAME }}.sha256
        asset_content_type: text/plain

  build-and-push-docker:
    name: Build and Push Docker Images
    runs-on: ubuntu-latest
    needs: create-release
    permissions:
      contents: read
      packages: write
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=tag
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          type=semver,pattern={{major}}
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        platforms: linux/amd64,linux/arm64
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        build-args: |
          VERSION=${{ needs.create-release.outputs.version }}
          COMMIT=${{ github.sha }}
          DATE=${{ github.event.head_commit.timestamp }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Generate SBOM
      uses: anchore/sbom-action@v0
      with:
        image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.create-release.outputs.version }}
        format: spdx-json
        output-file: sbom.spdx.json

    - name: Upload SBOM to Release
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ needs.create-release.outputs.upload_url }}
        asset_path: ./sbom.spdx.json
        asset_name: vault-sync-operator-${{ needs.create-release.outputs.version }}-sbom.spdx.json
        asset_content_type: application/json

  update-manifests:
    name: Update Kubernetes Manifests
    runs-on: ubuntu-latest
    needs: [create-release, build-and-push-docker]
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Update image version in manifests
      run: |
        VERSION=${{ needs.create-release.outputs.version }}
        # Update the image tag in the manager manifest
        sed -i "s|image: ghcr.io/${{ github.repository }}:.*|image: ghcr.io/${{ github.repository }}:${VERSION}|g" config/manager/manager.yaml
        
        # Create a versioned release manifest
        mkdir -p releases/${VERSION}
        cp -r config/* releases/${VERSION}/
        
        # Update kustomization.yaml with new image
        cat > releases/${VERSION}/kustomization.yaml << EOF
        apiVersion: kustomize.config.k8s.io/v1beta1
        kind: Kustomization
        
        resources:
        - crd/
        - rbac/
        - manager/
        
        images:
        - name: vault-sync-operator
          newName: ghcr.io/${{ github.repository }}
          newTag: ${VERSION}
        EOF

    - name: Create release manifest archive
      run: |
        VERSION=${{ needs.create-release.outputs.version }}
        cd releases/${VERSION}
        tar -czf ../../vault-sync-operator-manifests-${VERSION}.tar.gz .
        cd ../..

    - name: Upload Manifests to Release
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ needs.create-release.outputs.upload_url }}
        asset_path: ./vault-sync-operator-manifests-${{ needs.create-release.outputs.version }}.tar.gz
        asset_name: vault-sync-operator-manifests-${{ needs.create-release.outputs.version }}.tar.gz
        asset_content_type: application/gzip
