name: Release

on:
  push:
    tags:
      - 'v*'

env:
  GO_VERSION: "1.24"
  IMAGE_NAME: ${{ github.repository }}

permissions:
  contents: read
  packages: write

jobs:
  create-release:
    name: Create Release
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: read
    outputs:
      release_id: ${{ steps.create_release.outputs.id }}
      upload_url: ${{ steps.create_release.outputs.upload_url }}
      version: ${{ steps.get_version.outputs.version }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Get version from tag
      id: get_version
      run: echo "version=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT

    - name: Generate changelog
      id: changelog
      run: |
        # Get the latest two tags
        PREVIOUS_TAG=$(git tag --sort=-version:refname | sed -n '2p')
        CURRENT_TAG=${{ steps.get_version.outputs.version }}
        
        # If no previous tag, use initial commit
        if [ -z "$PREVIOUS_TAG" ]; then
          PREVIOUS_TAG=$(git rev-list --max-parents=0 HEAD)
        fi
        
        # Generate changelog
        echo "## Changes" > CHANGELOG.md
        echo "" >> CHANGELOG.md
        git log --pretty=format:"- %s (%h)" ${PREVIOUS_TAG}..${CURRENT_TAG} >> CHANGELOG.md
        echo "" >> CHANGELOG.md
        echo "" >> CHANGELOG.md
        echo "**Full Changelog**: https://github.com/${{ github.repository }}/compare/${PREVIOUS_TAG}...${CURRENT_TAG}" >> CHANGELOG.md

    - name: Create Release
      id: create_release
      run: |
        # Create the release using GitHub CLI
        CHANGELOG_BODY=$(cat CHANGELOG.md)
        PRERELEASE_FLAG=""
        if [[ "${{ steps.get_version.outputs.version }}" == *"-"* ]]; then
          PRERELEASE_FLAG="--prerelease"
        fi
        
        RELEASE_OUTPUT=$(gh release create "${{ steps.get_version.outputs.version }}" \
          --title "Release ${{ steps.get_version.outputs.version }}" \
          --notes "${CHANGELOG_BODY}" \
          ${PRERELEASE_FLAG} \
          --generate-notes)
        
        # Extract upload URL and release ID for compatibility
        RELEASE_ID=$(gh api repos/${{ github.repository }}/releases/tags/${{ steps.get_version.outputs.version }} --jq '.id')
        UPLOAD_URL=$(gh api repos/${{ github.repository }}/releases/tags/${{ steps.get_version.outputs.version }} --jq '.upload_url')
        
        echo "id=${RELEASE_ID}" >> $GITHUB_OUTPUT
        echo "upload_url=${UPLOAD_URL}" >> $GITHUB_OUTPUT
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  build-binaries:
    name: Build Binaries
    runs-on: ubuntu-latest
    needs: create-release
    permissions:
      contents: write
    strategy:
      matrix:
        goos: [linux, darwin, windows]
        goarch: [amd64, arm64]
        exclude:
          - goos: windows
            goarch: arm64
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v5
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: Cache Go modules
      uses: actions/cache@v4
      with:
        path: |
          ~/go/pkg/mod
        key: ${{ runner.os }}-go-mod-${{ env.GO_VERSION }}-${{ hashFiles('**/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-mod-${{ env.GO_VERSION }}-
          ${{ runner.os }}-go-mod-

    - name: Cache Go build cache
      uses: actions/cache@v4
      with:
        path: |
          ~/.cache/go-build
        key: ${{ runner.os }}-go-build-${{ env.GO_VERSION }}-${{ github.sha }}
        restore-keys: |
          ${{ runner.os }}-go-build-${{ env.GO_VERSION }}-
          ${{ runner.os }}-go-build-

    - name: Download dependencies
      run: go mod download

    - name: Build binary
      env:
        GOOS: ${{ matrix.goos }}
        GOARCH: ${{ matrix.goarch }}
        CGO_ENABLED: 0
      run: |
        BINARY_NAME="vault-sync-operator-${{ matrix.goos }}-${{ matrix.goarch }}"
        if [ "${{ matrix.goos }}" = "windows" ]; then
          BINARY_NAME="${BINARY_NAME}.exe"
        fi
        
        go build \
          -a \
          -ldflags="-w -s -extldflags '-static' -X main.version=${{ needs.create-release.outputs.version }} -X main.commit=${{ github.sha }} -X main.date=$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
          -tags netgo,osusergo \
          -o "${BINARY_NAME}" \
          cmd/main.go

    - name: Create archive
      id: archive
      run: |
        BINARY_NAME="vault-sync-operator-${{ matrix.goos }}-${{ matrix.goarch }}"
        if [ "${{ matrix.goos }}" = "windows" ]; then
          BINARY_NAME="${BINARY_NAME}.exe"
          ARCHIVE_NAME="vault-sync-operator-${{ needs.create-release.outputs.version }}-${{ matrix.goos }}-${{ matrix.goarch }}.zip"
          zip "${ARCHIVE_NAME}" "${BINARY_NAME}" README.md LICENSE
        else
          ARCHIVE_NAME="vault-sync-operator-${{ needs.create-release.outputs.version }}-${{ matrix.goos }}-${{ matrix.goarch }}.tar.gz"
          tar -czf "${ARCHIVE_NAME}" "${BINARY_NAME}" README.md LICENSE
        fi
        echo "archive_name=${ARCHIVE_NAME}" >> $GITHUB_OUTPUT
        echo "binary_name=${BINARY_NAME}" >> $GITHUB_OUTPUT

    - name: Upload Release Asset
      run: |
        gh release upload ${{ needs.create-release.outputs.version }} ${{ steps.archive.outputs.archive_name }}
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Generate SHA256 checksums
      run: |
        sha256sum ${{ steps.archive.outputs.archive_name }} > ${{ steps.archive.outputs.archive_name }}.sha256

    - name: Upload Checksum
      run: |
        gh release upload ${{ needs.create-release.outputs.version }} ${{ steps.archive.outputs.archive_name }}.sha256
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  build-and-push-docker:
    name: Build and Push Docker Images
    runs-on: ${{ matrix.runner }}
    needs: create-release
    permissions:
      contents: read
      packages: write
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: linux/amd64
            runner: ubuntu-latest
          - platform: linux/arm64
            runner: ubuntu-latest-arm64
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Prepare
      run: |
        platform=${{ matrix.platform }}
        echo "PLATFORM_PAIR=${platform//\//-}" >> $GITHUB_ENV

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ghcr.io
        username: danieldonoghue
        password: ${{ secrets.CR_PAT }}

    - name: Build and push by digest
      id: build
      uses: docker/build-push-action@v6
      with:
        context: .
        platforms: ${{ matrix.platform }}
        labels: |
          org.opencontainers.image.title=vault-sync-operator
          org.opencontainers.image.description=Kubernetes operator for syncing secrets to HashiCorp Vault
          org.opencontainers.image.version=${{ needs.create-release.outputs.version }}
          org.opencontainers.image.revision=${{ github.sha }}
          org.opencontainers.image.created=${{ github.event.head_commit.timestamp }}
          org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
          org.opencontainers.image.url=${{ github.server_url }}/${{ github.repository }}
        outputs: type=image,name=ghcr.io/${{ env.IMAGE_NAME }},push-by-digest=true,name-canonical=true,push=true
        provenance: false  # Reduces build time and complexity
        build-args: |
          VERSION=${{ needs.create-release.outputs.version }}
          COMMIT=${{ github.sha }}
          DATE=${{ github.event.head_commit.timestamp }}
        cache-from: type=gha,scope=${{ matrix.platform }}
        cache-to: type=gha,mode=max,scope=${{ matrix.platform }}

    - name: Export digest
      run: |
        mkdir -p /tmp/digests
        digest="${{ steps.build.outputs.digest }}"
        touch "/tmp/digests/${digest#sha256:}"

    - name: Upload digest
      uses: actions/upload-artifact@v4
      with:
        name: digests-${{ env.PLATFORM_PAIR }}
        path: /tmp/digests/*
        if-no-files-found: error
        retention-days: 1

  merge:
    name: Merge multi-platform manifests
    runs-on: ubuntu-latest
    needs: 
      - create-release
      - build-and-push-docker
    permissions:
      contents: write
      packages: write
    steps:
    - name: Download digests
      uses: actions/download-artifact@v4
      with:
        path: /tmp/digests
        pattern: digests-*
        merge-multiple: true

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ghcr.io
        username: danieldonoghue
        password: ${{ secrets.CR_PAT }}

    - name: Create manifest list and push
      working-directory: /tmp/digests
      run: |
        VERSION="${{ needs.create-release.outputs.version }}"
        
        # Create base tags
        TAGS=(
          "ghcr.io/${{ env.IMAGE_NAME }}:${VERSION}"
        )
        
        # Extract semantic version components (remove 'v' prefix if present)
        CLEAN_VERSION="${VERSION#v}"
        
        # Check if this is a pre-release (contains hyphen)
        IS_PRERELEASE=false
        if [[ "$VERSION" == *"-"* ]]; then
          IS_PRERELEASE=true
        fi
        
        # Only add 'latest' tag for stable releases (not pre-releases)
        if [[ "$IS_PRERELEASE" == false ]]; then
          TAGS+=("ghcr.io/${{ env.IMAGE_NAME }}:latest")
        fi
        
        # Only add semantic tags for proper semver releases (not pre-releases)
        if [[ "$IS_PRERELEASE" == false ]] && [[ "$CLEAN_VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
          # Split version into parts
          IFS='.' read -ra VERSION_PARTS <<< "$CLEAN_VERSION"
          MAJOR="${VERSION_PARTS[0]}"
          MINOR="${VERSION_PARTS[1]}"
          
          # Add semantic version tags
          TAGS+=(
            "ghcr.io/${{ env.IMAGE_NAME }}:${CLEAN_VERSION}"
            "ghcr.io/${{ env.IMAGE_NAME }}:${MAJOR}.${MINOR}"
            "ghcr.io/${{ env.IMAGE_NAME }}:${MAJOR}"
          )
        fi
        
        # Build tag arguments
        TAG_ARGS=""
        for tag in "${TAGS[@]}"; do
          TAG_ARGS="$TAG_ARGS -t $tag"
        done
        
        echo "Creating manifest list with tags: ${TAGS[*]}"
        if [[ "$IS_PRERELEASE" == true ]]; then
          echo "⚠️  Pre-release detected - skipping 'latest' and semantic version tags"
        fi
        
        # Create and push manifest list
        docker buildx imagetools create $TAG_ARGS \
          $(printf 'ghcr.io/${{ env.IMAGE_NAME }}@sha256:%s ' *)

    - name: Inspect image
      run: |
        docker buildx imagetools inspect ghcr.io/${{ env.IMAGE_NAME }}:${{ needs.create-release.outputs.version }}

    - name: Generate and Upload SBOM
      uses: anchore/sbom-action@v0
      with:
        image: ghcr.io/${{ env.IMAGE_NAME }}:${{ needs.create-release.outputs.version }}
        format: spdx-json
        artifact-name: vault-sync-operator-${{ needs.create-release.outputs.version }}-sbom.spdx.json
        upload-artifact: false
        upload-release-assets: true
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  update-manifests:
    name: Update Kubernetes Manifests
    runs-on: ubuntu-latest
    needs: [create-release, merge]
    permissions:
      contents: write
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Update image version in manifests
      run: |
        VERSION=${{ needs.create-release.outputs.version }}
        # Update the image tag in all manifest files
        sed -i "s|image: ghcr.io/${{ github.repository }}:.*|image: ghcr.io/${{ github.repository }}:${VERSION}|g" config/manager/manager.yaml
        sed -i "s|image: ghcr.io/${{ github.repository }}:.*|image: ghcr.io/${{ github.repository }}:${VERSION}|g" deploy/manual/04-deployment.yaml
        
        # Update the appVersion in Helm chart
        sed -i "s|appVersion: \".*\"|appVersion: \"${VERSION}\"|g" charts/vault-sync-operator/Chart.yaml
        
        # Update version references in documentation
        sed -i "s|tag: \"v[0-9]\+\.[0-9]\+\.[0-9]\+[^\"]*\"|tag: \"${VERSION}\"|g" docs/DEPLOYMENT.md
        
        # Create a versioned release manifest
        mkdir -p releases/${VERSION}
        cp -r config/* releases/${VERSION}/
        
        # Update kustomization.yaml with new image
        cat > releases/${VERSION}/kustomization.yaml << EOF
        apiVersion: kustomize.config.k8s.io/v1beta1
        kind: Kustomization
        
        resources:
        - crd/
        - rbac/
        - manager/
        
        images:
        - name: vault-sync-operator
          newName: ghcr.io/${{ github.repository }}
          newTag: ${VERSION}
        EOF

    - name: Create release manifest archive
      run: |
        VERSION=${{ needs.create-release.outputs.version }}
        cd releases/${VERSION}
        tar -czf ../../vault-sync-operator-manifests-${VERSION}.tar.gz .
        cd ../..

    - name: Package Helm chart
      run: |
        VERSION=${{ needs.create-release.outputs.version }}
        # Create Helm chart package
        cd charts
        tar -czf ../vault-sync-operator-helm-${VERSION}.tar.gz vault-sync-operator/
        cd ..

    - name: Upload Manifests to Release
      run: |
        gh release upload ${{ needs.create-release.outputs.version }} vault-sync-operator-manifests-${{ needs.create-release.outputs.version }}.tar.gz
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Upload Helm Chart to Release
      run: |
        gh release upload ${{ needs.create-release.outputs.version }} vault-sync-operator-helm-${{ needs.create-release.outputs.version }}.tar.gz
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Commit version updates
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add -A
        git diff --staged --quiet || git commit -m "chore: update version to ${{ needs.create-release.outputs.version }}"
        git push
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
